#!/bin/sh
# === load konfigurasi tunggal (opsional) ===
ENV_FILE="${ENV_FILE:-/etc/hgled.env}"
[ -f "$ENV_FILE" ] && . "$ENV_FILE"
# hgled — GPIO Wrapper + Internet Indicator + Rotor Clash/YACD (BusyBox-friendly)
# Fitur:
#   hgled -power on|off|warn|dis
#   hgled -lan   on|off|warn|dis
#   hgled -usb   reset
#   hgled -ir    on|off
#   hgled -r     (restart/daemonize indikator LED — EXTERNAL_STATE aware)
#   hgled -s     (stop indikator LED)
#   hgled -l     (loop LED di foreground)
#   hgled -rotor on|off|stop  (mulai/berhenti/stop rotor konektivitas + sinkron LED)
#
# Aturan rotor (untuk group SGR_ACTIVE, IDN_ACTIVE, WRD_ACTIVE):
# - Group tidak ada ping: ping 2x jeda 3s -> jika gagal, curl /group/<G>/delay -> tunggu 2s -> ping 1x -> gagal => mark_fail
# - Group ada ping: mark_ok; tunggu per-grup (SGR:120s, IDN:100s, WRD:80s) sebelum ping berikutnya
# - Jika semua group mark_fail: LED offline; curl semua group -> 2s -> ping semua -> jika tetap fail: /usr/bin/modem ip, tunggu 10s, lalu ping semua group lagi
# - Jika minimal satu group OK: LED Online
# ================== KONFIG LED ==================
SERVICE_NAME="Internet Indicator"
CHECK_URL="${CHECK_URL:-http://www.gstatic.com/generate_204}"  # (dipakai jika EXTERNAL_STATE=0)
HTTP_TIMEOUT="${HTTP_TIMEOUT:-5}"
FALLBACK_INTERVAL="${FALLBACK_INTERVAL:-0.1}"
PIDFILE="/var/run/internet-indicator.pid"
STATEFILE="/var/run/internet-indicator.state"
GPIO="/sys/class/gpio"
EXTERNAL_STATE="${EXTERNAL_STATE:-0}"   # 1 = LED mengikuti file STATEFILE (dikontrol rotor)
# ================== KONFIG ROTOR ==================
CTRL="${CTRL:-http://127.0.0.1:9090}"
SECRET="${SECRET:-12345}"                        # Bearer utk /proxies/<name>/delay
GROUPS="${GROUPS:-SGR_ACTIVE IDN_ACTIVE WRD_ACTIVE}"
PING_URL="${PING_URL:-https://www.gstatic.com/generate_204}"
TIMEOUT_MS="${TIMEOUT_MS:-3000}"                 # utk /proxies/*/delay

# Delay per-grup (detik) - tunda ping berikutnya
SGR_ACTIVE_DELAY="${SGR_ACTIVE_DELAY:-120}"      # 120 detik untuk SGR_ACTIVE
IDN_ACTIVE_DELAY="${IDN_ACTIVE_DELAY:-100}"      # 100 detik untuk IDN_ACTIVE
WRD_ACTIVE_DELAY="${WRD_ACTIVE_DELAY:-80}"       # 80 detik untuk WRD_ACTIVE

RETRY_GAP_SEC="${RETRY_GAP_SEC:-3}"              # jeda antar 2 retry saat grup gagal
AFTER_CURL_WAIT_SEC="${AFTER_CURL_WAIT_SEC:-2}"  # tunggu 2 detik setelah curl fallback
MODEM_CMD="${MODEM_CMD:-/usr/bin/modem ip}"
MODEM_WAIT_SEC="${MODEM_WAIT_SEC:-10}"           # tunggu 10 detik setelah modem ip
ROTOR_PIDFILE="/var/run/hgled-rotor.pid"
# ================== UTIL UMUM ==================
is_root(){ [ "$(id -u)" -eq 0 ] || { echo "Run as root"; exit 1; }; }
need_root_or_exit(){ [ "$(id -u)" -eq 0 ] || { echo "This command must be run as root" 1>&2; exit 1; }; }
log() {
  local ts; ts="$(date '+%F %T')"
  command -v logger >/dev/null 2>&1 && logger -t "hgled" "$*"
  printf '%s %s\n' "$ts" "$*"
}
sleep_compat(){
  d="$1"
  case "$d" in
    0) return 0 ;;
    0.5) if command -v usleep >/dev/null 2>&1; then usleep 500000; else sleep 1; fi ;;
    *) sleep "$d" ;;
  esac
}
# ================== GPIO/LED ==================
gpio_setup(){ p="$1"; [ -z "$p" ] && return 0; [ -d "$GPIO/gpio$p" ] || echo "$p" > "$GPIO/export" 2>/dev/null; echo out > "$GPIO/gpio$p/direction" 2>/dev/null; }
gpio_write(){ p="$1"; v="$2"; [ -z "$p" ] && return 0; echo "$v" > "$GPIO/gpio$p/value" 2>/dev/null; }
dual_general(){
  m="$1"; on="$2"; off="$3"
  gpio_setup "$on"; gpio_setup "$off"
  case "$m" in
    on)   [ -n "$off" ] && gpio_write "$off" 0; [ -n "$on" ] && gpio_write "$on" 1 ;;
    off)  [ -n "$on" ] && gpio_write "$on" 0; [ -n "$off" ] && gpio_write "$off" 1 ;;
    warn) [ -n "$on" ] && gpio_write "$on" 1; [ -n "$off" ] && gpio_write "$off" 1 ;;
    dis)  [ -n "$on" ] && gpio_write "$on" 0; [ -n "$off" ] && gpio_write "$off" 0 ;;
  esac
}
power(){ need_root_or_exit; dual_general "$1" "521" "517"; }  # hijau=521, merah=517
lan()  { need_root_or_exit; dual_general "$1" "547" "548"; }  # hijau=547, merah=548
usb(){ need_root_or_exit; u="505"; gpio_setup "$u"; [ "$1" = reset ] && { gpio_write "$u" 0; sleep 1; gpio_write "$u" 1; }; }
ir()   { need_root_or_exit; dual_general "$1" "" "507"; }     # hanya pin_off
# ================== shim hgledon ==================
hgledon(){
  case "$1" in
    -power) power "$2" ;;
    -lan)   lan   "$2" ;;
    -usb)   usb   "$2" ;;
    -ir)    ir    "$2" ;;
    *) echo "hgledon usage: -power|-lan [on|off|warn|dis] | -usb reset | -ir on|off" 1>&2; return 1 ;;
  esac
}
# ================== HEALTH/LED SERVICE ==================
cleanup_led(){
  hgledon -lan dis 2>/dev/null
  hgledon -power dis 2>/dev/null
  [ -n "${HEALTH_PID:-}" ] && kill "${HEALTH_PID}" 2>/dev/null
  rm -f "$STATEFILE" 2>/dev/null
}
check_online(){
  if command -v curl >/dev/null 2>&1; then
    curl --silent --show-error --head --fail --connect-timeout 3 --max-time "$HTTP_TIMEOUT" -o /dev/null "$CHECK_URL"
  else
    wget -q --spider "$CHECK_URL"
  fi
}
start_health_check_bg(){
  if [ -n "${HEALTH_PID:-}" ] && kill -0 "${HEALTH_PID}" 2>/dev/null; then return; fi
  ( if check_online; then printf "online" >"$STATEFILE"; else printf "offline" >"$STATEFILE"; fi ) &
  HEALTH_PID=$!
}
step_delay(){
  case "$1:$2" in
    online:0)  printf "2" ;;
    online:1)  printf "0" ;;
    online:2)  printf "2" ;;
    online:3)  printf "0" ;;
    offline:0) printf "1" ;;
    offline:1) printf "0" ;;
    offline:2) printf "1" ;;
    offline:3) printf "0" ;;
    *)         printf "%s" "$FALLBACK_INTERVAL" ;;
  esac
}
do_step(){
  m="$1"; s="$2"
  case "$m:$s" in
    online:0)  hgledon -power on  ;;
    online:1)  hgledon -power dis ;;
    online:2)  hgledon -lan   on  ;;
    online:3)  hgledon -lan   dis ;;
    offline:0) hgledon -power off ;;
    offline:1) hgledon -power dis ;;
    offline:2) hgledon -lan   off ;;
    offline:3) hgledon -lan   dis ;;
    *) : ;;
  esac
}
read_led_state(){ [ -s "$STATEFILE" ] && cat "$STATEFILE" 2>/dev/null || echo ""; }
write_led_state(){ printf "%s" "$1" > "$STATEFILE" 2>/dev/null || true; }

# Modifikasi loop_led dengan logika baru untuk EXTERNAL_STATE=0
loop_led(){
  trap 'cleanup_led; exit 0' INT TERM
  hgledon -lan dis
  hgledon -power dis

  # Logika baru untuk EXTERNAL_STATE=0: ping 5 detik, LED terus menerus
  if [ "$EXTERNAL_STATE" = "0" ]; then
    log "LED Service started in EXTERNAL_STATE=0 mode (ping every 5s)"
    while :; do
      if check_online; then
        # LED Mode online terus menerus
        hgledon -power on
        hgledon -lan on
        log "Internet OK - LED online mode"
        sleep 5
      else
        # LED Mode offline terus menerus
        hgledon -power off
        hgledon -lan off
        log "Internet FAIL - LED offline mode, ping every 3s until success"
        # Ping ulang setiap 3 detik hingga berhasil
        until check_online; do 
          sleep 3
          log "Retrying ping..."
        done
        log "Internet restored - back to 5s interval"
      fi
    done
    return
  fi

  # Logika lama untuk EXTERNAL_STATE=1 (dikontrol rotor)
  log "LED Service started in EXTERNAL_STATE=1 mode (rotor controlled)"
  printf "offline" >"$STATEFILE" 2>/dev/null || true
  mode="offline"; step=0; HEALTH_PID=""
  last_desired="offline"; flip_streak=0
  start_health_check_bg
  while :; do
    desired=""
    [ -s "$STATEFILE" ] && desired="$(cat "$STATEFILE" 2>/dev/null)"
    if [ "$desired" = "online" ] || [ "$desired" = "offline" ]; then
      if [ "$desired" != "$mode" ]; then
        if [ "$desired" = "$last_desired" ]; then
          flip_streak=$((flip_streak+1))
        else
          flip_streak=1
          last_desired="$desired"
        fi
        if [ "$flip_streak" -ge 2 ]; then
          prev_step="$step"
          mode="$desired"
          flip_streak=0
          case "$prev_step" in
            0|2) step="$prev_step" ;;
            1|3) step=$(( (prev_step + 1) % 4 )) ;;
            *)   step=0 ;;
          esac
        fi
      else
        flip_streak=0
        last_desired="$mode"
      fi
    fi
    do_step "$mode" "$step"
    delay="$(step_delay "$mode" "$step")"
    step=$(( (step + 1) % 4 ))
    [ "$delay" != "0" ] && sleep_compat "$delay"
    if [ -z "${HEALTH_PID:-}" ] || ! kill -0 "${HEALTH_PID}" 2>/dev/null; then
      start_health_check_bg
    fi
  done
}

start_led(){
  is_root
  mkdir -p "$(dirname "$PIDFILE")"
  if [ -f "$PIDFILE" ] && kill -0 "$(cat "$PIDFILE" 2>/dev/null)" 2>/dev/null; then
    echo "$SERVICE_NAME already running (pid $(cat "$PIDFILE"))."
    return 0
  fi
  rm -f "$PIDFILE" 2>/dev/null
  EXTERNAL_STATE="${EXTERNAL_STATE}" "$0" -l </dev/null >/dev/null 2>&1 &
  PID=$!
  echo "$PID" > "$PIDFILE"
  if command -v usleep >/dev/null 2>&1; then usleep 200000; else sleep 1; fi
  if [ -n "$PID" ] && kill -0 "$PID" 2>/dev/null; then
    echo "Started $SERVICE_NAME (pid $PID) with EXTERNAL_STATE=${EXTERNAL_STATE}."
  else
    echo "ERROR: failed to start $SERVICE_NAME" 1>&2
    rm -f "$PIDFILE" 2>/dev/null
    return 1
  fi
}
stop_led(){
  stopped=""
  if [ -f "$PIDFILE" ]; then
    pid="$(cat "$PIDFILE" 2>/dev/null)"
    if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
      kill "$pid"
      for i in 1 2 3; do kill -0 "$pid" 2>/dev/null || break; sleep 1; done
      stopped="yes"
    fi
    rm -f "$PIDFILE"
  fi
  pids="$(ps w | grep '[h]gled -l' | awk '{print $1}')"
  [ -n "$pids" ] && echo "$pids" | xargs -r kill && stopped="yes"
  cleanup_led
  if [ -n "$stopped" ]; then echo "Stopped $SERVICE_NAME."; else echo "$SERVICE_NAME not running."; fi
}
# ================== ROTOR (Clash/YACD) ==================
STATE_DIR="${STATE_DIR:-/tmp/hgled-rotor}"
mkdir -p "$STATE_DIR"
ok_file(){ echo "$STATE_DIR/$1.ok"; }
ts_now(){ date +%s; }

# Fungsi cache dengan delay per-grup spesifik (tanpa fallback RECHECK_SEC)
is_ok_cached(){ 
  g="$1"; f="$(ok_file "$g")"; [ -f "$f" ] || return 1; 
  now="$(ts_now)"; old="$(cat "$f" 2>/dev/null || echo 0)"
  
  # Delay spesifik per grup (tidak ada fallback)
  case "$g" in
    SGR_ACTIVE) delay="$SGR_ACTIVE_DELAY" ;;
    IDN_ACTIVE) delay="$IDN_ACTIVE_DELAY" ;;
    WRD_ACTIVE) delay="$WRD_ACTIVE_DELAY" ;;
    *) return 1 ;;  # grup tidak dikenal langsung return fail (tidak ada fallback)
  esac
  
  [ $((now - old)) -lt "$delay" ]
}

mark_ok(){ date +%s > "$(ok_file "$1")"; }
mark_fail(){ rm -f "$(ok_file "$1")" 2>/dev/null || true; }
any_ok_now(){ for g in $GROUPS; do is_ok_cached "$g" && return 0; done; return 1; }
# Ping via /proxies/<name>/delay (YACD-style)
ping_group(){
  g="$1"; enc="$(printf '%s' "$g" | sed 's/ /%20/g')"
  maxs=$(( (TIMEOUT_MS/1000) + 2 ))
  out="$(
    curl -sS --max-time "$maxs" -H "Authorization: Bearer $SECRET" -G \
      --data-urlencode "url=$PING_URL" \
      --data-urlencode "timeout=$TIMEOUT_MS" \
      "$CTRL/proxies/$enc/delay" 2>/dev/null || true
  )"
  printf '%s' "$out" | grep -q '"delay"'
}
# Fallback per grup: /group/<name>/delay (sesuai permintaan, Bearer 12345)
force_group_delay(){
  g="$1"
  out="$(
    curl -sS -H "Authorization: Bearer 12345" -G \
      --data-urlencode 'url=https://www.gstatic.com/generate_204' \
      --data-urlencode 'timeout=2000' \
      "http://127.0.0.1:9090/group/$g/delay" 2>/dev/null || true
  )"
  printf '%s' "$out" | grep -q '"delay"'
}
set_led_online(){ write_led_state "online"; }
set_led_offline(){ write_led_state "offline"; }
rotor_once_for_group(){
  G="$1"
  # Lewati jika masih OK (cache per-grup)
  if is_ok_cached "$G"; then return 0; fi
  # ping #1
  if ping_group "$G"; then mark_ok "$G"; log "OK: $G (ping #1)"; return 0; fi
  # ping #2 (jeda 3s)
  sleep "$RETRY_GAP_SEC"
  if ping_group "$G"; then mark_ok "$G"; log "OK: $G (ping #2)"; return 0; fi
  # ping #3 (jeda 3s)
  sleep "$RETRY_GAP_SEC"
  if ping_group "$G"; then mark_ok "$G"; log "OK: $G (ping #3)"; return 0; fi
  # 2x gagal (ping#2 & ping#3 gagal) → jalankan curl fallback, tunggu 2s, ping sekali
  log "FALLBACK: $G -> /group/$G/delay"
  force_group_delay "$G" >/dev/null 2>&1 || true
  sleep "$AFTER_CURL_WAIT_SEC"
  if ping_group "$G"; then
    mark_ok "$G"; log "OK: $G (after fallback)"
  else
    mark_fail "$G"; log "FAIL: $G (after fallback) -> mark_fail"
  fi
}
rotor_cycle(){
  # proses semua grup sesuai aturan
  for G in $GROUPS; do rotor_once_for_group "$G"; done
  if any_ok_now; then
    set_led_online
    return 0
  fi
  # Semua mark_fail: LED offline, coba mass-curl -> 2s -> mass-ping
  set_led_offline
  log "ALERT: semua group mark_fail -> mass curl"
  for G in $GROUPS; do force_group_delay "$G" >/dev/null 2>&1 || true; done
  sleep "$AFTER_CURL_WAIT_SEC"
  # Ping semua lagi
  any_ok=0
  for G in $GROUPS; do
    if ping_group "$G"; then mark_ok "$G"; any_ok=1; log "OK: $G (after mass-curl)"; else mark_fail "$G"; fi
  done
  if [ "$any_ok" -eq 1 ]; then
    set_led_online
    return 0
  fi
  # Tetap semua gagal → modem ip, tunggu 10s, ping semua group
  log "ALERT: tetap gagal -> $MODEM_CMD"
  sh -c "$MODEM_CMD" || log "WARN: gagal menjalankan $MODEM_CMD"
  sleep "$MODEM_WAIT_SEC"
  any_ok2=0
  for G in $GROUPS; do
    if ping_group "$G"; then mark_ok "$G"; any_ok2=1; log "OK: $G (after modem ${MODEM_WAIT_SEC}s)"; else mark_fail "$G"; fi
  done
  if [ "$any_ok2" -eq 1 ]; then set_led_online; else set_led_offline; fi
}
rotor_loop(){
  trap 'rm -f "$ROTOR_PIDFILE" 2>/dev/null; exit 0' INT TERM
  # Pastikan LED service jalan dalam EXTERNAL_STATE=1 dan stop LED service EXTERNAL_STATE=0
  stop_led  # Stop existing LED service
  EXTERNAL_STATE=1 "$0" -r >/dev/null 2>&1 || true
  # Set default LED offline sampai ada OK
  set_led_offline
  while :; do
    rotor_cycle
    sleep 1
  done
}

# Modifikasi rotor_on untuk selalu menggunakan EXTERNAL_STATE=1
rotor_on(){
  is_root
  if [ -f "$ROTOR_PIDFILE" ] && kill -0 "$(cat "$ROTOR_PIDFILE" 2>/dev/null)" 2>/dev/null; then
    echo "Rotor already running (pid $(cat "$ROTOR_PIDFILE"))."
    return 0
  fi
  rm -f "$ROTOR_PIDFILE" 2>/dev/null
  # Force EXTERNAL_STATE=1 saat rotor aktif, nonaktifkan ping EXTERNAL_STATE=0
  log "Starting rotor with EXTERNAL_STATE=1 (disabling EXTERNAL_STATE=0 ping)"
  "$0" __rotor_loop </dev/null >/dev/null 2>&1 &
  echo $! > "$ROTOR_PIDFILE"
  if command -v usleep >/dev/null 2>&1; then usleep 200000; else sleep 1; fi
  echo "Started rotor (pid $(cat "$ROTOR_PIDFILE")). EXTERNAL_STATE=0 ping disabled."
}

rotor_off(){
  if [ -f "$ROTOR_PIDFILE" ]; then
    pid="$(cat "$ROTOR_PIDFILE" 2>/dev/null)"
    [ -n "$pid" ] && kill "$pid" 2>/dev/null || true
    rm -f "$ROTOR_PIDFILE"
  fi
  # Matikan LED sesuai permintaan
  hgledon -power off
  hgledon -lan   off
  echo "Rotor stopped and LED set to power off + lan off."
}

# Fungsi rotor_stop - stop rotor tapi LED sync tetap hidup dengan EXTERNAL_STATE=0
rotor_stop(){
  if [ -f "$ROTOR_PIDFILE" ]; then
    pid="$(cat "$ROTOR_PIDFILE" 2>/dev/null)"
    [ -n "$pid" ] && kill "$pid" 2>/dev/null || true
    rm -f "$ROTOR_PIDFILE"
  fi
  
  # Restart LED service dalam mode EXTERNAL_STATE=0 (ping 5 detik)
  EXTERNAL_STATE=0 "$0" -r >/dev/null 2>&1 || true
  
  echo "Rotor stopped. LED sync continues with EXTERNAL_STATE=0 (ping every 5s)."
}

# ================== CLI ==================
print_usage(){
  cat <<EOF
Usage:
  LED/GPIO:
    hgled -power  on|off|warn|dis
    hgled -lan    on|off|warn|dis
    hgled -usb    reset
    hgled -ir     on|off
  LED Service:
    hgled -r      # restart/daemonize LED (EXTERNAL_STATE aware)
    hgled -s      # stop LED
    hgled -l      # run LED loop in foreground
  Rotor:
    hgled -rotor on    # start rotor dengan grup monitoring (EXTERNAL_STATE=1)
    hgled -rotor off   # stop rotor dan matikan LED
    hgled -rotor stop  # stop rotor, LED sync EXTERNAL_STATE=0 (ping 5s)
Env penting:
  CTRL=$CTRL
  SECRET=$SECRET
  GROUPS="$GROUPS"
  SGR_ACTIVE_DELAY=$SGR_ACTIVE_DELAY detik
  IDN_ACTIVE_DELAY=$IDN_ACTIVE_DELAY detik  
  WRD_ACTIVE_DELAY=$WRD_ACTIVE_DELAY detik
  PING_URL=$PING_URL
  TIMEOUT_MS=$TIMEOUT_MS
  RETRY_GAP_SEC=$RETRY_GAP_SEC
  AFTER_CURL_WAIT_SEC=$AFTER_CURL_WAIT_SEC
  MODEM_CMD="$MODEM_CMD" (wait $MODEM_WAIT_SEC s)
  STATEFILE=$STATEFILE  (LED online/offline)
  EXTERNAL_STATE=$EXTERNAL_STATE (0=ping 5s, 1=rotor controlled)
EOF
}
case "${1:-}" in
  -power) [ -n "${2:-}" ] || { print_usage; exit 1; }; power "$2" ;;
  -lan)   [ -n "${2:-}" ] || { print_usage; exit 1; }; lan   "$2" ;;
  -usb)   [ -n "${2:-}" ] || { print_usage; exit 1; }; usb   "$2" ;;
  -ir)    [ -n "${2:-}" ] || { print_usage; exit 1; }; ir    "$2" ;;
  -l)     loop_led ;;
  -r)     stop_led; start_led ;;
  -s)     stop_led ;;
  -rotor)
      case "${2:-}" in
        on)   rotor_on ;;
        off)  rotor_off ;;
        stop) rotor_stop ;;
        *)    echo "Usage: hgled -rotor on|off|stop"; exit 1 ;;
      esac
      ;;
  __rotor_loop) rotor_loop ;;
  -h|--help|"") print_usage ;;
  *) echo "Unknown option: $1" 1>&2; print_usage; exit 1 ;;
esac
